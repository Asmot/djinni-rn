/**
  * Copyright 2014 Dropbox, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  * 
  * This file has been modified by Snap, Inc.
  */

package djinni

import djinni.ast.Record.DerivingType
import djinni.ast._
import djinni.generatorTools._
import djinni.meta._
import djinni.writer.IndentWriter
import djinni.utils._
import mustache._


import scala.collection.mutable

import java.io.{File, FileNotFoundException, InputStreamReader, FileInputStream, Writer}
import java.io.StringWriter
/*
if is record, only generate toReadableMap and fromReadableMap

*/
class RNJavaGenerator(spec: Spec) extends Generator(spec) {

  val javaAnnotationHeader = spec.javaAnnotation.map(pkg => '@' + pkg.split("\\.").last)
  val javaNullableAnnotation = spec.javaNullableAnnotation.map(pkg => '@' + pkg.split("\\.").last)
  val javaNonnullAnnotation = spec.javaNonnullAnnotation.map(pkg => '@' + pkg.split("\\.").last)
  val javaClassAccessModifierString = JavaAccessModifier.getCodeGenerationString(spec.javaClassAccessModifier)
  val marshal = new JavaMarshal(spec)

  // read the rn java template file
  val rnJavaTemplate = utils.readFileCon(spec.rn_javaTemplateFile.get);


  var PRE_STR = "SRN"

  class JavaRefs() {
    var java = mutable.TreeSet[String]()

    spec.javaAnnotation.foreach(pkg => java.add(pkg))
    spec.javaNullableAnnotation.foreach(pkg => java.add(pkg))
    spec.javaNonnullAnnotation.foreach(pkg => java.add(pkg))

    def find(ty: TypeRef) { find(ty.resolved) }
    def find(tm: MExpr) {
      tm.args.foreach(find)
      find(tm.base)
    }
    def find(m: Meta) = for(r <- marshal.references(m)) r match {
      case ImportRef(arg) => java.add(arg)
      case _ =>
    }
  }

  def writeJavaFile(ident: String, origin: String, refs: Iterable[String], f: IndentWriter => Unit) {
    createFile(spec.rn_javaOutFolder.get, idJava.ty(ident) + ".java", (w: IndentWriter) => {
      w.wl("// AUTOGENERATED FILE - DO NOT MODIFY!")
      w.wl("// This file was generated by Djinni from " + origin)
      w.wl
      spec.rn_javaPackage.foreach(s => w.wl(s"package $s;").wl)
      if (refs.nonEmpty) {
        refs.foreach(s => w.wl(s"import $s;"))
        w.wl
      }
      f(w)
    })
  }

  def generateJavaConstants(w: IndentWriter, consts: Seq[Const]) = {

    def writeJavaConst(w: IndentWriter, ty: TypeRef, v: Any): Unit = v match {
      case l: Long if marshal.fieldType(ty).equalsIgnoreCase("long") => w.w(l.toString + "l")
      case l: Long => w.w(l.toString)
      case d: Double if marshal.fieldType(ty).equalsIgnoreCase("float") => w.w(d.toString + "f")
      case d: Double => w.w(d.toString)
      case b: Boolean => w.w(if (b) "true" else "false")
      case s: String => w.w(s)
      case e: EnumValue =>  w.w(s"${marshal.typename(ty)}.${idJava.enum(e)}")
      case v: ConstRef => w.w(idJava.const(v))
      case z: Map[_, _] => { // Value is record
        val recordMdef = ty.resolved.base.asInstanceOf[MDef]
        val record = recordMdef.body.asInstanceOf[Record]
        val vMap = z.asInstanceOf[Map[String, Any]]
        w.wl(s"new ${marshal.typename(ty)}(")
        w.increase()
        // Use exact sequence
        val skipFirst = SkipFirst()
        for (f <- record.fields) {
          skipFirst {w.wl(",")}
          writeJavaConst(w, f.ty, vMap.apply(f.ident.name))
          w.w(" /* " + idJava.field(f.ident) + " */ ")
        }
        w.w(")")
        w.decrease()
      }
    }

    for (c <- consts) {
      writeDoc(w, c.doc)
      javaAnnotationHeader.foreach(w.wl)
      marshal.nullityAnnotation(c.ty).foreach(w.wl)
      w.w(s"public static final ${marshal.fieldType(c.ty)} ${idJava.const(c.ident)} = ")
      writeJavaConst(w, c.ty, c.value)
      w.wl(";")
      w.wl
    }
  }

  private val moduleClass: String = spec.javaIdentStyle.ty(spec.moduleName) + "Module"

  override def generateModule(decls: Seq[InternTypeDecl]) {
    if (spec.jniUseOnLoad) {
      writeJavaFile(moduleClass, s"${spec.moduleName} Module", List.empty, w => {
        w.wl(s"public final class $moduleClass").braced {
          w.wl("static").braced {
            w.wl("if (System.getProperty(\"java.vm.vendor\").equals(\"The Android Project\"))").braced {
              w.wl("Guard.initialize();")
            }
          }
          w.wl("private static final class Guard").braced {
            w.wl("private static native void initialize();")
          }
        }
      })
    }
  }

  override def generateEnum(origin: String, ident: Ident, doc: Doc, e: Enum) {
    // enum no need to generate again can use the java directily
  }

  
  override def generateInterface(origin: String, ident: Ident, doc: Doc, typeParams: Seq[TypeParam], i: Interface) {
    // only deal the interface which have annotation
  }
  override def generateInterface(origin: String, ident: Ident, doc: Doc, typeParams: Seq[TypeParam], i: Interface, annotation: Option[Annotation]) {
    val refs = new JavaRefs()
    i.methods.map(m => {
      m.params.map(p => refs.find(p.ty))
      m.ret.foreach(refs.find)
    })
    i.consts.map(c => {
      refs.find(c.ty)
    })

    def writeModuleInitializer(w: IndentWriter) = {
      if (spec.jniUseOnLoad) {
        w.wl("static").braced {
          w.wl("try").braced {
            w.wl(s"Class.forName(${q(spec.javaPackage.getOrElse("") + "." + moduleClass)});")
          }
          w.wl("catch (ClassNotFoundException e)").braced {
            w.wl(s"throw new IllegalStateException(${q("Failed to initialize djinni module")}, e);")
          }
        }
      }
    }
    val javaClass = marshal.typename(ident, i)
    val typeParamList = javaTypeParams(typeParams)
    var javaFileName = s"${PRE_STR}$javaClass${typeParamList}Manager"

    val template = new Mustache(rnJavaTemplate)
    var jsonDataMap = scala.collection.mutable.Map(
      "className" -> javaClass,
      "functions" -> List[scala.collection.mutable.Map[String, Any]]()
    )
    var jsonDataFunctions = List[scala.collection.mutable.Map[String, Any]]()
    writeJavaFile(javaFileName, origin, refs.java, w => {        
      
      var counter = 1;
      val throwException = spec.javaCppException.fold("")(" throws " + _)
      // no return will set to prop
      for (m <- i.methods if !m.static) {
        // only generate with annotation
        // if have annotation generate a ReactProp name is the annotation value
        // and change the overlay value call the same function name
        m.annotation.getOrElse(None) match {
          case Annotation(ident, value) => {    

            val jsonDataProp = scala.collection.mutable.Map[String, Any]();

            val docWriter = new StringWriter();
            val innerW = new IndentWriter(docWriter);
            writeMethodDoc(innerW, m, idJava.local)
            // doce
            jsonDataProp.put("functionDoc" , docWriter.toString());
            // annotation
            jsonDataProp(s"${ident.name}Annotation") = true;
             // remmove ""
            jsonDataProp("annotaionValue") = value.replaceAll(""""""","")

            // function name and index (id)
            jsonDataProp("functionName") = m.ident.name;
            jsonDataProp("functionNameId") = counter;
            counter = counter + 1;

            // return
            val ret = marshal.returnType(m.ret)

            val jsonDataReturn = scala.collection.mutable.Map[String, Any]();
            m.ret.getOrElse(None) match {
              case TypeRef(resolved) => {
                  jsonDataProp("haveReturn") = true;
                  jsonDataReturn("returnType") = ret;
                  m.ret.get.resolved.base match {
                    case t: MPrimitive => t.jName match {
                      case "byte" | "short" | "int" | "float" | "double" | "long" => {
                        jsonDataReturn("returnIsNumber") = true
                      }
                      case "boolean" => jsonDataReturn("returnIsBool") = true
                    }
                    case df: MDef => df.defType match {
                      case DRecord => jsonDataReturn("returnIsObject") = true
                    }
                  }
                }
              case None => jsonDataProp("haveReturn") = false;
            }
            
            val params = m.params.map(p => {
              val nullityAnnotation = marshal.nullityAnnotation(p.ty).map(_ + " ").getOrElse("")
              nullityAnnotation + marshal.paramType(p.ty) + " " + idJava.local(p.ident)
            })
            marshal.nullityAnnotation(m.ret).foreach(w.wl)
            jsonDataProp("return") = jsonDataReturn;

            // params
            jsonDataProp("haveParams") = (m.params.length > 0);
            jsonDataProp("oneParam") = (m.params.length == 1);
            jsonDataProp("params") = List[scala.collection.mutable.Map[String, Any]]();            

            var jsonDataParams = List[scala.collection.mutable.Map[String, Any]]();            
            for (parm <- m.params) {
              val parm_field = parm;

              var jsonDataParm = scala.collection.mutable.Map[String, Any]();
              jsonDataParm("paramName") = parm_field.ident.name
              jsonDataParm("paramType") = marshal.paramType(parm_field.ty)
              
              parm_field.ty.resolved.base match {
                case t: MPrimitive => t.jName match {
                  case "byte" | "short" | "int" | "float" | "double" | "long" => {
                    jsonDataParm("paramIsNumber") = true
                  }
                  case "boolean" => jsonDataParm("paramIsBool") = true
                }
                case df: MDef => df.defType match {
                  case DRecord => jsonDataParm("paramIsObject") = true
                }
              }
              jsonDataParams = jsonDataParams :+ jsonDataParm;
              
            }
            jsonDataProp("params") = jsonDataParams;
            jsonDataFunctions = jsonDataFunctions :+ jsonDataProp;
            
          }
          case None => {};
        }
        
      }
      jsonDataMap("functions") = jsonDataFunctions;
      val formatedOutput = template.render(jsonDataMap)
      // System.out.println(jsonDataMap)
      w.wl(formatedOutput)
      
    })
  }

  override def generateRecord(origin: String, ident: Ident, doc: Doc, params: Seq[TypeParam], r: Record) {
    val refs = new JavaRefs()
    r.fields.foreach(f => refs.find(f.ty))

    // rn java
    refs.java.add("com.facebook.react.bridge.ReadableMap");
    refs.java.add("com.facebook.react.bridge.WritableMap");
    refs.java.add("com.facebook.react.bridge.WritableNativeMap");
    // for smap TODO add to spec
    refs.java.add("com.smap.maps.model.*");

    val javaName = if (r.ext.java) (ident.name + "_base") else (PRE_STR + ident.name)
    val javaFinal = if (!r.ext.java && spec.javaUseFinalForRecord) "public final " else ""

    writeJavaFile(javaName, origin, refs.java, w => {
      writeDoc(w, doc)
      javaAnnotationHeader.foreach(w.wl)
      val self = marshal.typename(javaName, r)

      w.w(s"${javaClassAccessModifierString}${javaFinal}class ${self + javaTypeParams(params)}").braced {
        w.wl
        generateJavaConstants(w, r.consts)

        // toWritableMap
        w.wl
        w.w(s"public static WritableMap toWritableMap(${ident.name} item)" ).braced {
          w.wl("if (item == null) {return null;}")
          w.wl("WritableMap result = new WritableNativeMap();")
          for (f <- r.fields) {
            f.ty.resolved.base match {
              case t: MPrimitive => t.jName match {
                case "byte" | "short" | "int" | "float" | "double" | "long"   
                    => w.wl(s"""result.putDouble("${f.ident.name}", item.${f.ident.name});""")
                case "boolean"
                    => w.wl(s"""result.putBoolean("${f.ident.name}", item.${f.ident.name});""")
                    
              }
              case df: MDef => df.defType match {
                case DRecord => w.wl(s"""result.putMap("${f.ident.name}", ${PRE_STR}${marshal.typename(f.ty)}.toWritableMap(item.${f.ident.name}));""")
                case _ => w.wl(s"// not support! ${f.ident.name}")//throw new AssertionError("Unreachable")
              }
              case _ => w.wl(s"// not support! ${f.ident.name}")
            }
          }
          w.wl("return result;")
        }
        
        // fromReadableMap

        // convert readableMap to java object ,with hasKey check
        // eg result.tilt = (float)data.getDouble("tilt");  
        def fromReadableMapHasKeyCheck = (fieldName:String, castFieldType : String, isBool: Boolean) => {
          if (isBool) {
            w.wl(s"""if (data.hasKey("${fieldName}")) {""")
            w.wl(s"""   result.${fieldName} = data.getBoolean("${fieldName}");""")
            w.wl("}")
          } else {
            w.wl(s"""if (data.hasKey("${fieldName}")) {""")
            w.wl(s"""   result.${fieldName} = (${castFieldType})data.getDouble("${fieldName}");""")
            w.wl("}")
          }  
        }

        w.wl
        w.w(s"public static ${ident.name} fromReadableMap(ReadableMap data)" ).braced {
          w.wl("if (data == null) {return null;}")
          w.wl(s"${ident.name} result = new ${ident.name}();")
          for (f <- r.fields) {
            f.ty.resolved.base match {
              case t: MPrimitive => t.jName match {
                case "byte" | "short" | "double" | "long"   
                    => fromReadableMapHasKeyCheck(s"${f.ident.name}", "double", false)
                case "float" => fromReadableMapHasKeyCheck(s"${f.ident.name}", "float", false)
                case "int" => fromReadableMapHasKeyCheck(s"${f.ident.name}", "int", false)
                case "boolean" => fromReadableMapHasKeyCheck(s"${f.ident.name}", "boolean", true)
              }
              case df: MDef => df.defType match {
                case DRecord => 
                    w.wl(s"""if (data.hasKey("${f.ident.name}")) {""")
                    w.wl(s"""   result.${f.ident.name} = ${PRE_STR}${marshal.typename(f.ty)}.fromReadableMap(data.getMap("${f.ident.name}"));""")
                    w.wl(s"}")
                case _ => w.wl(s"// not support! ${f.ident.name}")
              }
              case _ => w.wl(s"// not support! ${f.ident.name}")
            }
          }
          w.wl("return result;")
        }

        if (spec.javaImplementAndroidOsParcelable && r.derivingTypes.contains(DerivingType.AndroidParcelable))
          writeParcelable(w, self, r);

        if (r.derivingTypes.contains(DerivingType.Ord)) {
          def primitiveCompare(ident: Ident) {
            w.wl(s"if (this.${idJava.field(ident)} < other.${idJava.field(ident)}) {").nested {
              w.wl(s"tempResult = -1;")
            }
            w.wl(s"} else if (this.${idJava.field(ident)} > other.${idJava.field(ident)}) {").nested {
              w.wl(s"tempResult = 1;")
            }
            w.wl(s"} else {").nested {
              w.wl(s"tempResult = 0;")
            }
            w.wl("}")
          }
          w.wl
          w.wl("@Override")
          val nonnullAnnotation = javaNonnullAnnotation.map(_ + " ").getOrElse("")
          w.w(s"public int compareTo($nonnullAnnotation$self other) ").braced {
            w.wl("int tempResult;")
            for (f <- r.fields) {
              f.ty.resolved.base match {
                case MString | MDate => w.wl(s"tempResult = this.${idJava.field(f.ident)}.compareTo(other.${idJava.field(f.ident)});")
                case t: MPrimitive => primitiveCompare(f.ident)
                case df: MDef => df.defType match {
                  case DRecord => w.wl(s"tempResult = this.${idJava.field(f.ident)}.compareTo(other.${idJava.field(f.ident)});")
                  case DEnum => w.w(s"tempResult = this.${idJava.field(f.ident)}.compareTo(other.${idJava.field(f.ident)});")
                  case _ => throw new AssertionError("Unreachable")
                }
                case e: MExtern => e.defType match {
                  case DRecord => if(e.java.reference) w.wl(s"tempResult = this.${idJava.field(f.ident)}.compareTo(other.${idJava.field(f.ident)});") else primitiveCompare(f.ident)
                  case DEnum => w.w(s"tempResult = this.${idJava.field(f.ident)}.compareTo(other.${idJava.field(f.ident)});")
                  case _ => throw new AssertionError("Unreachable")
                }
                case _ => throw new AssertionError("Unreachable")
              }
              w.w("if (tempResult != 0)").braced {
                w.wl("return tempResult;")
              }
            }
            w.wl("return 0;")
          }
        }

      }
    })
  }

  def javaTypeParams(params: Seq[TypeParam]): String =
    if (params.isEmpty) "" else params.map(p => idJava.typeParam(p.ident)).mkString("<", ", ", ">")

  def writeParcelable(w: IndentWriter, self: String, r: Record) = {
    // Generates the methods and the constructor to implement the interface android.os.Parcelable

    // CREATOR
    w.wl
    w.wl(s"public static final android.os.Parcelable.Creator<$self> CREATOR")
    w.w(s"    = new android.os.Parcelable.Creator<$self>()").bracedSemi {
      w.wl("@Override")
      w.w(s"public $self createFromParcel(android.os.Parcel in)").braced {
        w.wl(s"return new $self(in);")
      }
      w.wl
      w.wl("@Override")
      w.w(s"public $self[] newArray(int size)").braced {
        w.wl(s"return new $self[size];")
      }
    }

    // constructor (Parcel)
    def deserializeField(f: Field, m: Meta, inOptional: Boolean) {
      m match {
        case MString => w.wl(s"this.${idJava.field(f.ident)} = in.readString();")
        case MBinary => {
          w.wl(s"this.${idJava.field(f.ident)} = in.createByteArray();")
        }
        case MDate => w.wl(s"this.${idJava.field(f.ident)} = new ${marshal.typename(f.ty)}(in.readLong());")
        case t: MPrimitive => t.jName match {
          case "short" => w.wl(s"this.${idJava.field(f.ident)} = (short)in.readInt();")
          case "int" => w.wl(s"this.${idJava.field(f.ident)} = in.readInt();")
          case "long" => w.wl(s"this.${idJava.field(f.ident)} = in.readLong();")
          case "byte" => w.wl(s"this.${idJava.field(f.ident)} = in.readByte();")
          case "boolean" => w.wl(s"this.${idJava.field(f.ident)} = in.readByte() != 0;")
          case "float" => w.wl(s"this.${idJava.field(f.ident)} = in.readFloat();")
          case "double" => w.wl(s"this.${idJava.field(f.ident)} = in.readDouble();")
          case _ => throw new AssertionError("Unreachable")
        }
        case df: MDef => df.defType match {
          case DRecord => w.wl(s"this.${idJava.field(f.ident)} = new ${marshal.typename(f.ty)}(in);")
          case DEnum => w.wl(s"this.${idJava.field(f.ident)} = ${marshal.typename(f.ty)}.values()[in.readInt()];")
          case _ => throw new AssertionError("Unreachable")
        }
        case e: MExtern => e.defType match {
          case DRecord => w.wl(s"this.${idJava.field(f.ident)} = ${e.java.readFromParcel.format(marshal.typename(f.ty))};")
          case DEnum => w.wl(s"this.${idJava.field(f.ident)} = ${marshal.typename(f.ty)}.values()[in.readInt()];")
          case _ => throw new AssertionError("Unreachable")
        }
        case MList => {
          w.wl(s"this.${idJava.field(f.ident)} = new ${marshal.typename(f.ty)}();")
          w.wl(s"in.readList(this.${idJava.field(f.ident)}, getClass().getClassLoader());")
        }
        case MSet =>  {
          val collectionTypeName = marshal.typename(f.ty).replaceFirst("HashSet<(.*)>", "$1")
          w.wl(s"ArrayList<${collectionTypeName}> ${idJava.field(f.ident)}Temp = new ArrayList<${collectionTypeName}>();")
          w.wl(s"in.readList(${idJava.field(f.ident)}Temp, getClass().getClassLoader());")
          w.wl(s"this.${idJava.field(f.ident)} = new ${marshal.typename(f.ty)}(${idJava.field(f.ident)}Temp);")
        }
        case MMap => {
          w.wl(s"this.${idJava.field(f.ident)} = new ${marshal.typename(f.ty)}();")
          w.wl(s"in.readMap(this.${idJava.field(f.ident)}, getClass().getClassLoader());")
        }
        case MOptional => {
          if (inOptional)
          	throw new AssertionError("nested optional?")
          w.wl("if (in.readByte() == 0) {").nested {
            w.wl(s"this.${idJava.field(f.ident)} = null;")
          }
          w.wl("} else {").nested {
            deserializeField(f, f.ty.resolved.args.head.base, true)
          }
          w.wl("}")
        }
        case _ => throw new AssertionError("Unreachable")
      }
    }
    w.wl
    w.w(s"public $self(android.os.Parcel in)").braced {
      for (f <- r.fields)
        deserializeField(f, f.ty.resolved.base, false)
    }

    // describeContents
    w.wl
    w.wl("@Override")
    w.w("public int describeContents()").braced {
      w.wl("return 0;")
    }

    // writeToParcel
    def serializeField(f: Field, m: Meta, inOptional: Boolean) {
      m match {
        case MString => w.wl(s"out.writeString(this.${idJava.field(f.ident)});")
        case MBinary => {
          w.wl(s"out.writeByteArray(this.${idJava.field(f.ident)});")
        }
        case MDate => w.wl(s"out.writeLong(this.${idJava.field(f.ident)}.getTime());")
        case t: MPrimitive => t.jName match {
          case "short" | "int" => w.wl(s"out.writeInt(this.${idJava.field(f.ident)});")
          case "long" => w.wl(s"out.writeLong(this.${idJava.field(f.ident)});")
          case "byte" => w.wl(s"out.writeByte(this.${idJava.field(f.ident)});")
          case "boolean" => w.wl(s"out.writeByte(this.${idJava.field(f.ident)} ? (byte)1 : 0);")
          case "float" => w.wl(s"out.writeFloat(this.${idJava.field(f.ident)});")
          case "double" => w.wl(s"out.writeDouble(this.${idJava.field(f.ident)});")
          case _ => throw new AssertionError("Unreachable")
        }
        case df: MDef => df.defType match {
          case DRecord => w.wl(s"this.${idJava.field(f.ident)}.writeToParcel(out, flags);")
          case DEnum => w.wl(s"out.writeInt(this.${idJava.field(f.ident)}.ordinal());")
          case _ => throw new AssertionError("Unreachable")
        }
        case e: MExtern => e.defType match {
          case DRecord => w.wl(e.java.writeToParcel.format(idJava.field(f.ident)) + ";")
          case DEnum => w.wl(s"out.writeInt(this.${idJava.field(f.ident)}.ordinal());")
          case _ => throw new AssertionError("Unreachable")
        }
        case MList => {
          w.wl(s"out.writeList(this.${idJava.field(f.ident)});")
        }
        case MSet => {
          val collectionTypeName = marshal.typename(f.ty).replaceFirst("HashSet<(.*)>", "$1")
          w.wl(s"out.writeList(new ArrayList<${collectionTypeName}>(this.${idJava.field(f.ident)}));")
        }
        case MMap => w.wl(s"out.writeMap(this.${idJava.field(f.ident)});")
        case MOptional => {
          if (inOptional)
          	throw new AssertionError("nested optional?")
          w.wl(s"if (this.${idJava.field(f.ident)} != null) {").nested {
            w.wl("out.writeByte((byte)1);")
            serializeField(f, f.ty.resolved.args.head.base, true)
          }
          w.wl("} else {").nested {
            w.wl("out.writeByte((byte)0);")
          }
          w.wl("}")
        }
        case _ => throw new AssertionError("Unreachable")
      }
    }

    w.wl
    w.wl("@Override")
    w.w("public void writeToParcel(android.os.Parcel out, int flags)").braced {
      for (f <- r.fields)
        serializeField(f, f.ty.resolved.base, false)
    }
    w.wl
  }

}
